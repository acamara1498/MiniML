(** A mini-ML
    @author Stuart M. Shieber

    This module implements a small untyped ML-like language under
    various operational semantics.
 *)

open Expr ;;
  
(* Exception for evaluator runtime generated by a runtime error *)
exception EvalError of string ;;
(* Exception for evaluator runtime generated by an explicit "raise" construct *)
exception EvalException ;;

module type Env_type = sig
    type env
    type value =
       | Val of expr
       | Closure of (expr * env)
    val create : unit -> env
    val close : expr -> env -> value
    val lookup : env -> varid -> value
    val extend : env -> varid -> value ref -> env
    val update : env -> varid -> value ref -> env
    val env_to_string : env -> string
    val value_to_string : ?printenvp:bool -> value -> string
  end

module Env : Env_type =
  struct

    type env = (varid * value ref) list
     and value =
       | Val of expr
       | Closure of (expr * env)

    exception EnvUnbound

    (* Creates an empty environment *)
    let create () : env = [] ;;

    (* Creates a closure from an expression and the environment it's
       defined in *)
    let close (exp: expr) (env: env) : value = Closure (exp, env) ;;

    (* Looks up the value of a variable in the environment *)
    let lookup (env: env) (varname: varid) : value =
      try !(List.assoc varname env) with Not_found -> raise EnvUnbound
    ;;

    (* Returns a new environment just like env except that it maps the
       variable varid to loc *)
    let extend (env: env) (varname: varid) (loc: value ref) : env =
      (varname, loc) :: env ;;

    (* update variable's value *)
    let rec update (env: env) (varname: varid) (loc: value ref) : env =
      match env with
      | [] -> []
      | (id, v) :: tl ->
        if id = varname
        then ((id, loc) :: tl)
        else ((id, v) :: (update tl varname loc))
     ;;

    (* Returns a printable string representation of an environment *)
    let rec env_to_string (env: env) : string =
      let rec aux e =
	    match e with
        | [] -> "\n"
        | (id, v) :: tl -> id ^ (value_to_string !v) ^ (aux tl) in
      aux env

    (* Returns a printable string representation of a value; the flag
       printenvp determines whether to include the environment in the
       string representation when called on a closure *)
    and value_to_string ?(printenvp : bool = true) (v: value) : string =
      match v with
      | Val exp -> exp_to_string exp
      | Closure (exp, env) ->
          if printenvp
          then exp_to_string exp ^ " : " ^ (env_to_string env)
          else exp_to_string exp
    ;;
  end
;;
	     
(* The evaluation function: Returns the result of type `value` of
   evaluating the expression `exp` in the environment `env`. In this
   initial implementation, we just convert the expression unchanged to
   a value and return it. *)

let unopeval (op: string) (v1: expr) : expr =
  match op, v1 with
  | "~" , Num x -> Num (~- x)
  | _ , _ -> raise EvalException
;;

let binopeval (op: string) (v1: expr) (v2: expr) : expr =
  match op, v1, v2 with
  | "+", Num x1, Num x2 -> Num (x1 + x2)
  | "+", _, _ -> raise (EvalError "can't add non-ints")
  | "*", Num x1, Num x2 -> Num (x1 * x2)
  | "*", _, _ -> raise (EvalError "can't multiply non-ints")
  | "-", Num x1, Num x2 -> Num (x1 - x2)
  | "-", _, _ -> raise (EvalError "can't subtract non-ints")
  | "/", Num x1, Num x2 ->
    if x2 != 0 then Num (x1 / x2)
    else raise (EvalError "Division by zero")
  | "/", _, _ -> raise (EvalError "can't divide non-ints")
  | "=", Num x1, Num x2 -> Bool (x1 = x2)
  | _, _, _  -> raise (EvalError "can't divide non-ints")
;;

(* evaluate using substitution *)
let rec eval (exp: expr) : expr =
  match exp with
  | Num _ | Bool _ -> exp
  | Raise | Unassigned -> exp
  | Var x -> raise EvalException
  | Unop (op, e) -> unopeval op (eval e)
  | Binop (op, e1, e2) -> binopeval op (eval e1) (eval e2)
  | Conditional (e1, e2, e3) -> if eval e1 = Bool true then eval e2 else eval e3
  | Fun (_, _) -> exp
  | Let (x, def, body) -> eval (subst x (eval def) body)
  | Letrec (x, def, body) -> eval (subst x (eval def) body)
  | App (f, q) ->
    match eval f with
    | Fun(def, body) -> eval (subst def (eval q) body)
    | _ -> raise (EvalError "only functions can be applied")
;;

(* evaluate with dynamic scoping *)
let rec evald exp env =
  match exp with
  | Num _ | Bool _ | Fun (_, _) | Raise | Unassigned -> (Env.Val exp)
  | Var x -> Env.lookup env x
  | Unop (op, e) -> (match evald e env with
	| Env.Val p -> Env.Val (unopeval op p)
    | _ -> raise EvalException)
  | Binop (op, e1, e2) -> (match (evald e1 env, evald e2 env) with
    | Env.Val p1, Env.Val p2 -> Env.Val (binopeval op p1 p2)
    | _ -> raise EvalException)
  | Conditional(e1, e2, e3) -> (match evald e1 env with
    | Env.Val (Bool b) -> (match b with
                           | true -> evald e2 env
                           | false -> evald e3 env)
    | _ -> raise EvalException)
  | Let(x, def, body) ->
    (match evald def env with
     | Env.Val p -> let env' = Env.extend env x (ref (Env.Val p)) in
          evald body env'
     | Env.Closure _ -> raise EvalException)
  | Letrec(x, def, body) ->
    let env' = Env.extend env x (ref (Env.Val Unassigned)) in
    (match evald def env' with
    | Env.Val Unassigned -> raise EvalException
    | Env.Val p -> let env'' = Env.extend env' x (ref (Env.Val p)) in
                               evald body env''
    | Env.Closure _ -> raise EvalException)
  | App(e1, e2) -> (match evald e1 env with
    | Env.Val (Fun (s, e1')) -> (match evald e2 env with
      | Env.Val v -> let env' = Env.extend env s (ref (Env.Val v)) in
                                evald e1' env'
      | Env.Closure _ -> raise (EvalError "closures aren't supported"))
    | _ -> raise  (EvalError "only functions can be applied"))
;;

(* part 5 extension: evaluate with lexical scoping *)
let rec eval_lex exp env =
  match exp with
  | Num _ | Bool _ | Raise | Unassigned -> (Env.Val exp)
  | Var x -> Env.lookup env x
  | Unop (op, e) -> (match eval_lex e env with
	| Env.Val p -> Env.Val (unopeval op p)
    | _ -> raise EvalException)
  | Binop (op, e1, e2) -> (match (eval_lex e1 env, eval_lex e2 env) with
    | Env.Val p1, Env.Val p2 -> Env.Val (binopeval op p1 p2)
    | _ -> raise EvalException)
  | Conditional(e1, e2, e3) -> (match eval_lex e1 env with
    | Env.Val (Bool b) -> (match b with
                           | true -> eval_lex e2 env
                           | false -> eval_lex e3 env)
    | _ -> raise EvalException)
  | Fun (s, e) -> (Env.Closure (exp, env))
  | Let(x, def, body) -> (match eval_lex def env with
    | Env.Val p -> let env' = Env.extend env x (ref (Env.Val p)) in
                              eval_lex body env'
	| Env.Closure (e, b) ->
	  let env' = Env.extend env x (ref (Env.Closure (e, b))) in
	  eval_lex body env')
  | Letrec(x, def, body) ->
    let env' = Env.extend env x (ref (Env.Val Unassigned)) in
    (match eval_lex def env' with
    | Env.Val Unassigned -> raise EvalException
    | Env.Val p -> let env'' = Env.extend env' x (ref (Env.Val p)) in
                               eval_lex body env''
    | Env.Closure (e, b) ->
      let b' = Env.update b x (ref (Env.Val e)) in
      let env'' = Env.update env' x (ref (Env.Closure (e, b'))) in
                  eval_lex body env'')
  | App(e1, e2) -> (match eval_lex e1 env with
    | Env.Val (Fun (x, q)) ->
      (match eval_lex e2 env with
      | Env.Val p as v -> let env' = Env.extend env x (ref v) in eval_lex q env'
      | Env.Closure p as v -> let env' = Env.extend env x (ref v) in
                                         eval_lex q env')
    | Env.Closure (Fun (x, q), env') ->
      (match eval_lex e2 env with
      | Env.Val p -> let env'' = Env.extend env' x (ref (Env.Val p)) in
                     eval_lex q env''
      | Env.Closure p -> let env'' = Env.extend env' x (ref (Env.Closure p)) in
                                     eval_lex q env'')
	| _ -> raise (EvalError "only functions can be applied"))
;;

let eval_t exp _env = Env.Val exp ;;
let eval_s exp _env = Env.Val (eval exp) ;;
let eval_d exp env = evald exp env ;;
let eval_l exp env = eval_lex exp env ;;

let evaluate = eval_s ;;

